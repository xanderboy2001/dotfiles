#!/usr/bin/env bash
set -euo pipefail


WORK_DIR="/tmp/dotfiles"
CONF_DIR="$(dirname "$0")/../.config"
PACMAN_CONF="/etc/pacman.conf"
# declare an empty array to be populated later
declare -a NEEDED_PKGS=()
declare -a SELECTED_PKGS=()
declare -a PKG_LIST=()

function confirm_yn {
    local choice="${1:-y}"
    case $choice in
        [yY]*)
            return 0 ;;
        [nN]*)
            return 1 ;;
    esac
}

function config_pacman {
    if ! [[ -f $PACMAN_CONF ]]; then
        echo "ERROR! ${PACMAN_CONF} does not exist! Pacman was not installed correctly!"
        exit
    else
        cp $PACMAN_CONF "${WORK_DIR}/pacman.conf.tmp"
        PACMAN_CONF="${WORK_DIR}/pacman.conf.tmp"
    fi
    echo "Checking if the multilib repository is enabled..."
    local arr=()
    mapfile -t arr < <(grep -A1 "\[multilib\]" $PACMAN_CONF)
    if [[ ${#arr[@]} -ne 2 ]]; then
        echo "ERROR. The string '[multilib]' was not found in your pacman configuration file (it should be!)"
        echo "This could mean pacman was not installed correctly."
        exit
    fi
        
    if [[ ${arr[0]} == \#* && ${arr[1]} == \#* ]]; then
        echo "Multilib is not enabled. Would you like to enable it?"
        echo "Multilib is required for many programs (like Steam)"
        read -rp "Install multilib? (Y/n) " CONFIRM
        if ( confirm_yn "$CONFIRM" ); then
            echo "Enabling the multilib repository..."
            sed -i "/\[multilib\]/,/Include/"'s/^#//' $PACMAN_CONF
        else
            echo "We cannot continue as Multilib is required for many programs"
            exit
        fi
    else
        echo "Multilib is already enabled"
    fi

    if ( grep -xq "^#Color" $PACMAN_CONF ); then
        read -rp "Color output is not enabled in pacman. Would you like to enable it? (Y/n) " CONFIRM
        if ( confirm_yn "$CONFIRM" ); then
            echo "Enabling color output in pacman..."
            sed -i 's/^#Color/Color/' $PACMAN_CONF
        else
            echo "You have selected NOT to enable color output in pacman"
        fi
    elif ( grep -xq "^Color" $PACMAN_CONF ); then
        echo "Color output is already enabled in pacman"
    else
        echo "ERROR: the 'Color' option is not present in /etc/pacman.conf!"
        echo "This could mean that your pacman.conf is not formatted correctlly, and/or pacman is not installed properly!"
        read -rp "Would you like to continue (we will NOT be enabling color output with this script)" CONFIRM
        if ! ( confirm_yn "$CONFIRM" ); then
            exit
        fi
    fi

    if ( grep -q "^#ParallelDownloads" $PACMAN_CONF ); then
        read -rp "Would you like to enable parallel downloads in pacman? (Y/n) " CONFIRM
        if ( confirm_yn "$CONFIRM" ); then
            read -rp "How many downloads would you like to run in parallel? (Default: 5) " PARALLEL_DL_COUNT
            if [[ -z $PARALLEL_DL_COUNT ]]; then
                PARALLEL_DL_COUNT=5
            fi
            sed -i "s/^#ParallelDownloads.*/ParallelDownloads = ${PARALLEL_DL_COUNT}/" $PACMAN_CONF
        fi
    fi
    echo "Installing our edited pacman.conf file..."
    sudo cp $PACMAN_CONF /etc/pacman.conf
}

function upgrade_system {
    echo "Updating the system packages and databases..."
    sudo pacman -Syyu --noconfirm
}

function check_dir {
    if ! [[ -d "$WORK_DIR" ]]; then
        echo "$WORK_DIR does not exist!"
        echo "Creating ${WORK_DIR}..."
        mkdir "$WORK_DIR"
        check_dir
    elif [[ -n "$(ls -A ${WORK_DIR})" ]]; then
        echo "${WORK_DIR} is not empty!"
        echo "Emptying ${WORK_DIR}..."
        rm -rf ${WORK_DIR:?}/*
        check_dir
    else
        echo "$WORK_DIR exists and is empty"
    fi
}

function check_pkg {
    local pkg=$1
    echo "Checking if ${pkg} is installed..."
    if pacman -Q "$pkg" &> /dev/null; then
        echo "${pkg} is installed!"
        return 0
    else
        echo "${pkg} is not installed!"
        return 1
    fi
}

function get_pkg_list {
    #PKG_LIST_URL="https://raw.githubusercontent.com/xanderboy2001/dotfiles/main/Scripts/pkgs"
    #curl "$PKG_LIST_URL" -o "${WORK_DIR}/pkg_list"
    cp $(dirname "$0")/pkgs "${WORK_DIR}/pkg_list"
    PKG_LIST_FILE="${WORK_DIR}/pkg_list"
    # Read pkgs file into PKGS array
    readarray -t PKG_LIST < "$PKG_LIST_FILE"
}

function check_pkg_list {
    echo "Checking for required packages..."
    # Iterates over packages in PKGS
    for pkg in "${PKG_LIST[@]}"; do
        # Checks if pkg is installed
        if ! (check_pkg "$pkg"); then
        # Adds packages not installed to NEEDED_PKGS
            NEEDED_PKGS+=("$pkg")
        fi
    done
}

function select_pkgs {
    # if NEEDED_PKGS isn't empty
    if [ -n "${NEEDED_PKGS[*]}" ]; then
        echo "The following packages are are not currently installed:"
        # Iterate over NEEDED_PKGS and print index variable
        i=1
        for pkg in "${NEEDED_PKGS[@]}"; do
            echo -e "$pkg [$i]"
            i=$((i+1))
        done | column -t
        # Read list of nums from stdin. Corresponds to index of pkg to install
        echo "Please indicate which packages to install... [A]ll, [N]one, [1 - ${#NEEDED_PKGS[@]}]"
        read -rp "(separate multiple choices by a space) Default: [A]ll " -a SELECTED_PKGS
        for i in "${!SELECTED_PKGS[@]}"; do
            SELECTED_PKGS[i]=${NEEDED_PKGS[$((${SELECTED_PKGS[$i]}))-1]}
        done
        # set $SELECTED_PKGS to 'A' (all) by default (no input)
        if [ ${#SELECTED_PKGS[@]} -eq 0 ]; then SELECTED_PKGS=('A'); fi
    fi
}

function install_pkgs {
    if [[ ${SELECTED_PKGS[*]} == 'A' || ${SELECTED_PKGS[*]} == 'a' ]]; then
        echo "You have selected to install all packages"
        paru -S --needed "${NEEDED_PKGS[@]}"
    elif [[ ${SELECTED_PKGS[*]} == 'N' || ${SELECTED_PKGS[*]} == 'n' ]]; then
        echo "You have selected NOT to install any packages"
        echo "Exiting..."
        exit
    else
        echo "We will install the following packages: ${SELECTED_PKGS[*]}"
        read -rp "Confirm (Y/n): " CONFIRM
        if ( confirm_yn "$CONFIRM" ); then
            paru -S --needed "${SELECTED_PKGS[@]}"
        else
            echo "You have chosen NOT to install any packages"
            echo "Exiting..."
            exit
        fi
    fi
}

function check_paru {
    if [ -f "/bin/paru" ]; then
        echo "Paru is already installed. Skipping..."
        return
    elif [ -f "/bin/yay" ]; then
        read -rp "Paru is not installed, but Yay is. Remove Yay and install Paru? (Y/n) " CONFIRM
        if ! (confirm_yn "$CONFIRM"); then
            echo "You have chosen to keep yay and skip the installation of paru"
            return
        elif ( confirm_yn "$CONFIRM"); then
            read -rp "This will uninstall yay and replace it with paru. Are you sure? (Y/n) " CONFIRM
            if ( confirm_yn "$CONFIRM"); then
                remove_yay
                install_paru
            else
                echo "Inconsistent answers. Redoing Paru/Yay check..."
                check_paru
            fi
        fi
    else
        echo "Paru is not installed."
        read -rp "Would you like to install paru? (NOTE: you will NOT be able to continue if you say no) (Y/n): " CONFIRM
        if ( confirm_yn "$CONFIRM" ); then
            install_paru
        else
            echo "Paru is the reccomended AUR wrapper. If you really don't want it, install yay and re-run this script."
            echo "The AUR and a wrapper are a hard requirement for this config. You will not be able to continue without it."
            exit
        fi
    fi
}

function remove_yay {
    echo "Removing yay..."
    sudo pacman --noconfirm -Rns yay
    echo "Yay has been removed"
}

function install_paru {
    echo "Installing paru..."
    echo "Checking for dependencies..."
    if ! (check_pkg base-devel); then
        echo "Installing base-devel..."
        sudo pacman -S --needed --noconfirm base-devel
    fi
    if ! (check_pkg git); then
        echo "Installing git..."
        sudo pacman -S --noconfirm git
    fi
    echo "Paru dependency check has succeeded"
    git clone "https://aur.archlinux.org/paru.git" "${WORK_DIR}/paru"
    cd "${WORK_DIR}/paru"
    makepkg -si
}

function install_nvidia {
    echo "Creating Xorg config file for nvidia"
    nvidia-xconfig
    echo "Removing kms hook from mkinitcpio.conf (Needed to blacklist nouveau driver"
    sed -ie 's/^HOOKS=(.*kms.*)/HOOKS=(base udev autodetect microcode modconf keyboard keymap consolefont block filesystems fsck)/' /etc/mkinitcpio.conf
    echo
    echo "YOU WILL NEED TO REBOOT YOUR MACHINE TO USE THE NEW DRIVER"
}

function add_bri_acct {
    echo "Adding a user account for Bri..."
    sudo useradd -m -U -s /bin/bash bri
    echo 'bri' | sudo passwd -s bri
    echo "Added user account for bri and set password to 'bri'"
}

function config_bees {
    DISK_NAME=$(lsblk -f lsblk -fr | awk '$2=="btrfs"{print $1}')
    UUID=$(lsblk -f /dev/sda2 | awk 'NR==2{print $3}')
    echo
    lsblk -fo NAME,FSTYPE,UUID,MOUNTPOINTS
    echo
    read -rp "Please review the output of lsblk and confirm that ${DISK_NAME} is the root btrfs partition and ${UUID} is the correct UUID (Y/n): "
    echo -e "UUID=${UUID}\nDB_SIZE=$((256*1024*1024))" | sudo tee /etc/bees/root.config > /dev/null
    sudo systemctl enable --now "beesd@${UUID}.service"
}

function install_configs {
    rsync -a "${CONF_DIR}"/* "${HOME}"/.config/
}

function start_networkManager {
    sudo systemctl enable --now NetworkManager.service
}

function config_git {
    git config --global user.name "Alexader Christian"
    git config --global user.email "alexanderechristian@gmail.com"
    git config --global init.defaultBranch master
}

function set_shell {
    sudo add-shell /usr/bin/fish
    chsh -s /usr/bin/fish
}

check_dir
echo
config_pacman
echo
upgrade_system
echo
check_paru
echo
get_pkg_list
echo
check_pkg_list
echo
select_pkgs
echo
install_pkgs
echo
install_nvidia
echo
add_bri_acct
echo
config_bees
echo
install_configs
echo
start_networkManager
echo
config_git
echo
set_shell
